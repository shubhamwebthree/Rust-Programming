fn add_one(x: &mut i32) { // function taking a mutable reference to an i32
    *x += 1; // increments the value the reference points to
}

fn main() {
    let mut num = 5; // our mutable variable
    add_one(&mut num); // pass a mutable reference to our variable
    println!("The value of num is: {}", num); // prints: The value of num is: 6
}

In the main function, we have the num variable — let's think of it as our own house. We're comfortable letting add_one temporarily hold the key to our house (the mutable reference to our num variable) because we trust that add_one will only make the specific change we have agreed on.

This agreement is referred to as 'scope'. The add_one function has a scope that is clearly defined by its function body. It can only make changes within this scope.

Once add_one does its job, that is, increments our num variable by one, its scope ends. It steps out, hands the key back, and it can no longer make any changes to our house. The key no longer works beyond the end of the add_one function, and the mutable reference it once had is no longer valid.

This mechanism is crucial for preserving data integrity as it ensures that changes made by functions are controlled, traceable, and limited to the intended scope. We rest assured that our house – or variable value – only changes when and where we expect.

-------------------------------------------------------------------

fn buy_apples(apple_count: &mut i32, apples_bought: i32) {
    *apple_count += apples_bought;
}

fn main() {
    let mut my_apple_count = 5; // Starting with 5 apples
    let shopping_cart = &mut my_apple_count;
    buy_apples(shopping_cart, 10); // Buying 10 more apples
    println!("I had {} apples; now I have {}!", 5, my_apple_count);
}
-------------------------------------------------------------------------
fn main() {
    let mut house_paint_color = String::from("Red");
    let house_address = &mut house_paint_color;

    // TODO: Update the `house_paint_color` to "Blue" using `house_address`.
    *house_address = "Blue".to_string();
    println!("The house is now painted in {}", house_paint_color);
}

-----------------------------------------------------------------------------
fn repaint_walls(color_address: &mut String) { // Incorrectly not allowing mutation
    *color_address = String::from("Blue"); // Attempt to change the color to "Blue"
}

fn main() {
    let mut current_color =  String::from("Red"); // The current color is "Red"
    repaint_walls(&mut current_color); // Attempting to pass a mutable reference
    println!("The new color of the walls is: {}", current_color);
}
-----------------------------------------------------------------------------
fn paint_walls(color_address: &mut String) {
    // TODO: Change the color value to something vibrant!
    *color_address = String::from("yellow");
}

fn main() {
    // TODO: Declare a mutable variable `wall_color` with the initial value "White".
    let mut wall_color = String::from("White");
    // TODO: Call `paint_walls` to change `wall_color`.
     paint_walls(&mut wall_color);
    // TODO: Print out the new color of the walls.
    println!("New color of the wall is {}",wall_color);
}
